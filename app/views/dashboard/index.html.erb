<% content_for :styles do %>
	<%= stylesheet_link_tag 'dashboard', media: 'all', 'data-turbolinks-track' => true %>
<% end %>


<body class="hold-transition skin-black">
	<div class="wrapper">
		<header class="main-header">
			<!-- header things -->
			placeholder for logo and stuff
			
		</header>
		<div >
			<section class="content-header">
			      <h1>
			        Dashboard
			        <small>: Let Visualize things!</small>
			      </h1>
			      <ol class="breadcrumb">
			        <li class="active" ><a href="#"><i class="fa fa-dashboard"></i> Home</a></li>
			        
			      </ol>
    		</section>
    		 <section class="content">
	    	    <div class="row" >
	    		 	<div id="sunburst" class="sunburst col-sm-5" style="float:left">
					
					</div>
	    		 	<div class="col-sm-2">
	    		 		<div class="box box-warning">
	    		 			<div class="box-header with-border">
	 				            <div class="form-group">
					                <label>Textarea</label>
	 				            	
					                	<textarea class="form-control prettyprint" id="editor" rows="25" placeholder="Enter ..."></textarea>
					            </div>
	    		 			</div>
	    		 		</div>
	    		 	</div>
			        <div class="col-sm-5">
			          <div class="box box-warning">
			            <div class="box-header with-border">
			              <h3 class="box-title">Display window</h3>

			              <div class="box-tools pull-right">
			                <button type="button" class="btn btn-box-tool" data-widget="collapse"><i class="fa fa-minus"></i>
			                </button>
			              </div>
			              <!-- /.box-tools -->
			            </div>
			            <!-- /.box-header -->
			            <div class="box-body" style="height:100-px">
			              Visualization
			            	<div id="chart"></div>
			             	 </div>
			            </div>
			          </div>
			        </div>	
	    		</div>
    		 </section>
		</div>
	</div>
</body>

<script src="//d3js.org/d3.v3.min.js"></script>


<script type="text/javascript">


				var width = 900,
				    height = 700,
				    radius = (Math.min(width, height) / 3) - 10;

				var formatNumber = d3.format(",d");

				var x = d3.scale.linear()
				    .range([0, 2 * Math.PI]);

				var y = d3.scale.sqrt()
				    .range([0, radius]);

				var color = d3.scale.category20c();

				var partition = d3.layout.partition()

				    .value(function(d) { return d.size; });

				var partition_value = d3.layout.partition()
				    // .children( function (d) {
				    // 	console.log('sstatatat');
				    // 	console.log(d);
				    // })
				    .value(function(d) { return d.value; });

				var arc = d3.svg.arc()
				    .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
				    .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
				    .innerRadius(function(d) { return Math.max(0, y(d.y)); })
				    .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });

				var svg = d3.select("#sunburst").append("svg")
				    .attr("width", width)
				    .attr("height", height)
				    .style("float","left")
				  .append("g")
				    .attr("transform", "translate(" + width / 2 + "," + (height / 2) + ")");
				    var root_copy;

		$("svg").css({top: -100, left: -150, position:'absolute'});

		$("#editor").on("keydown", function (e) {

			
				 if(e.keyCode == 32 || e.keyCode === 13 || e.keyCode==8){
	        		//your code
	        		console.log("presse");
				    var content = $('#editor').val();
				    // console.log(content);
				    var lastIndex = content.lastIndexOf(" ");
				    var words = content.replace(/\s\s+/g, ' ').trim(" ").split(" ");

				    words.forEach(function (d){ return d.replace(/\s/g, " ")});
				    // console.log(words);
				    var last_three_strings = words.slice(-3);
				    var laststing = content.substring(lastIndex);
					 
					// console.log(laststing);

					$.ajax({
						type: "GET",
						data:  {'word1' : laststing.replace(" ","")},
						contentType:  "application/json; charset=utf-8",
						url: '/dashboard/fetch_n_gram',
						dataType: 'json',
						success: function(data){
							var check_if_same = start(data);

							// console.log(check_if_same);
							if(!check_if_same) root_copy = data;
						}
						//error function
					})



			function start(root){			

				// console.log(root)
 				
 				if(root_copy != undefined){
	 					var flag_parent = 0;
	 					var flag_child = 0;
	 					//if root  == 3rd last word
	 					last_three_strings.forEach(function (d){ return d.replace(/\r?\n|\r/g, "")});

	 					console.log(last_three_strings);
	 				if (last_three_strings[0] == root_copy.name	){
			 				 root_copy.children.forEach(function (d){
			 				 	if (d.name == last_three_strings[1])
			 				 	{	
			 				 		console.log("3rd last matched");
			 				 		flag_parent = 1;
			 				 		type (d);
			 				 		if(last_three_strings.length ==3){

				 				 		d.children.forEach(function (d_child){
				 				 			if (d_child.name == last_three_strings[2])
				 				 			{
				 				 				flag_child =1;

				 				 				type (d_child);
				 				 				// setTimeout(function(){ console.log("out") },10000);
				 				 				// // return 1 ;
				 				 				// console.log('asfs');
				 				 			}
				 				 		});
				 				 		if (flag_child==1){
				 				 			return 0 ;
				 				 			//basically no found therefor continue
				 				 		}
			 				 		}
			 				 		else{
			 				 			return 1;
			 				 		}
			 				 	}
			 				 });

			 				 if(flag_parent == 1 ){
			 				 	return 1;
			 				 }

			 				 // if(flag_parent == 1 && flag_child ==0){
			 				 // 	return 1 ;
			 				 // }
			 				 // else if (flag_parent == 1 && flag_child ==1){
			 				 // 	//nothing
			 				 // }
	 				}
	 				else if (last_three_strings[1] == root_copy.name){
	 					root_copy.children.forEach(function (d){
	 						if (d.name == last_three_strings[2])
	 						{
	 							flag_parent = 1;
	 							type (d);
	 							return 1;
	 						}

	 					});
	 					if(flag_parent==1){
	 						return 1;
	 					}
	 				}

 				}



 				d3.selectAll("path").remove();

				  var sunburst = svg
				      .selectAll("path")
				      .data(partition.nodes(root));

				    
				    sunburst.exit().remove(); 

				   sunburst.enter()
				   	.append("path")
				      .attr("d", arc)
				      .style("fill", function(d) { return color((d.children ? d : d.parent).name); })
				      .attr("stroke","black")
				      // .attr("stroke-width",2)
				      .on("click", click)
				      .on("mouseover",path_sequence)
				    .append("title")
				      .text(function(d) { return d.name + "\n" + formatNumber(d.value); });


				      

				 // d3.selectAll("path")[0].forEach(function (d){


				 // 	console.log(d);
				 // });
				type(root);

				function path_sequence(d){
					console.log('data');
					console.log(d);
				}

				function click(d) {
					console.log(d)
					// console.log(d.x)
					$('#editor').val($('#editor').val() + " " +d.name)
				  svg.transition()
				      .duration(750)
				      .tween("scale", function() {
				        var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),
				            yd = d3.interpolate(y.domain(), [d.y, 1]),
				            yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]);
				        return function(t) { x.domain(xd(t)); y.domain(yd(t)).range(yr(t)); };
				      })
				    .selectAll("path")
				      .attrTween("d", function(d) { return function() { return arc(d); }; });
				}
				function type(d) {
					// console.log(d)
					// console.log(d.x)
				
				  svg.transition()
				      .duration(750)
				      .tween("scale", function() {
				        var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),
				            yd = d3.interpolate(y.domain(), [d.y, 1]),
				            yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]);
				        return function(t) { x.domain(xd(t)); y.domain(yd(t)).range(yr(t)); };
				      })
				    .selectAll("path")
				      .attrTween("d", function(d) { return function() { return arc(d); }; });
				}
				d3.select(self.frameElement).style("height", height + "px");

				return 0;
				}
    			}
		});




</script>
<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript">

window.addEventListener('message', function(e) {
    var opts = e.data.opts,
        data = e.data.data;

    return main(opts, data);
});

var defaults = {
    margin: {top: 24, right: 0, bottom: 0, left: 0},
    rootname: "TOP",
    format: ",d",
    title: "",
    width: 490,
    height: 500
};

function main(o, data) {
  var root,
      opts = $.extend(true, {}, defaults, o),
      formatNumber = d3.format(opts.format),
      rname = opts.rootname,
      margin = opts.margin,
      theight = 36 + 16;

  $('#chart').width(opts.width).height(opts.height);
  var width = opts.width - margin.left - margin.right,
      height = opts.height - margin.top - margin.bottom - theight,
      transitioning;
  
  var color = d3.scale.category20c();
  
  var x = d3.scale.linear()
      .domain([0, width])
      .range([0, width]);
  
  var y = d3.scale.linear()
      .domain([0, height])
      .range([0, height]);
  
  var treemap = d3.layout.treemap()
      .children(function(d, depth) { return depth ? null : d._children; })
      .sort(function(a, b) { return a.value - b.value; })
      .ratio(height / width * 0.5 * (1 + Math.sqrt(5)))
      .round(false);
  
  var svg = d3.select("#chart").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.bottom + margin.top)
      .style("margin-left", -margin.left + "px")
      .style("margin.right", -margin.right + "px")
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
      .style("shape-rendering", "crispEdges");
  
  var grandparent = svg.append("g")
      .attr("class", "grandparent");
  
  grandparent.append("rect")
      .attr("y", -margin.top)
      .attr("width", width)
      .attr("height", margin.top);
  
  grandparent.append("text")
      .attr("x", 6)
      .attr("y", 6 - margin.top)
      .attr("dy", ".75em");

  if (opts.title) {
    $("#chart").prepend("<p class='title'>" + opts.title + "</p>");
  }
  if (data instanceof Array) {
    root = { key: rname, values: data };
  } else {
    root = data;
  }
    
  initialize(root);
  accumulate(root);
  layout(root);
  console.log(root);
  display(root);

  if (window.parent !== window) {
    var myheight = document.documentElement.scrollHeight || document.body.scrollHeight;
    window.parent.postMessage({height: myheight}, '*');
  }

  function initialize(root) {
    root.x = root.y = 0;
    root.dx = width;
    root.dy = height;
    root.depth = 0;
  }

  // Aggregate the values for internal nodes. This is normally done by the
  // treemap layout, but not here because of our custom implementation.
  // We also take a snapshot of the original children (_children) to avoid
  // the children being overwritten when when layout is computed.
  function accumulate(d) {
    return (d._children = d.values)
        ? d.value = d.values.reduce(function(p, v) { return p + accumulate(v); }, 0)
        : d.value;
  }

  // Compute the treemap layout recursively such that each group of siblings
  // uses the same size (1×1) rather than the dimensions of the parent cell.
  // This optimizes the layout for the current zoom state. Note that a wrapper
  // object is created for the parent node for each group of siblings so that
  // the parent’s dimensions are not discarded as we recurse. Since each group
  // of sibling was laid out in 1×1, we must rescale to fit using absolute
  // coordinates. This lets us use a viewport to zoom.

  // KEY - ANSWER
  // REGION - TAG
  // SUB- REGION - QUESTION

  function layout(d) {
    if (d._children) {
      treemap.nodes({_children: d._children});
      d._children.forEach(function(c) {
        c.x = d.x + c.x * d.dx;
        c.y = d.y + c.y * d.dy;
        c.dx *= d.dx;
        c.dy *= d.dy;
        c.parent = d;
        layout(c);
      });
    }
  }

  function display(d) {
    grandparent
        .datum(d.parent)
        .on("click", transition)
      .select("text")
        .text(name(d));

    var g1 = svg.insert("g", ".grandparent")
        .datum(d)
        .attr("class", "depth");

    var g = g1.selectAll("g")
        .data(d._children)
      .enter().append("g");

    g.filter(function(d) { return d._children; })
        .classed("children", true)
        .on("click", transition);

    var children = g.selectAll(".child")
        .data(function(d) { return d._children || [d]; })
      .enter().append("g");

    children.append("rect")
        .attr("class", "child")
        .call(rect)
      .append("title")
        .text(function(d) { return d.key + " (" + formatNumber(d.value) + ")"; });
    children.append("text")
        .attr("class", "ctext")
        .text(function(d) { return d.key; })
        .call(text2);

    g.append("rect")
        .attr("class", "parent")
        .call(rect);

    var t = g.append("text")
        .attr("class", "ptext")
        .attr("dy", ".75em")

    t.append("tspan")
        .text(function(d) { return d.key; });
    t.append("tspan")
        .attr("dy", "1.0em")
        .text(function(d) { return formatNumber(d.value); });
    t.call(text);

    g.selectAll("rect")
        .style("fill", function(d) { return color(d.key); });

    function transition(d) {
      if (transitioning || !d) return;
      transitioning = true;

      var g2 = display(d),
          t1 = g1.transition().duration(750),
          t2 = g2.transition().duration(750);

      // Update the domain only after entering new elements.
      x.domain([d.x, d.x + d.dx]);
      y.domain([d.y, d.y + d.dy]);

      // Enable anti-aliasing during the transition.
      svg.style("shape-rendering", null);

      // Draw child nodes on top of parent nodes.
      svg.selectAll(".depth").sort(function(a, b) { return a.depth - b.depth; });

      // Fade-in entering text.
      g2.selectAll("text").style("fill-opacity", 0);

      // Transition to the new view.
      t1.selectAll(".ptext").call(text).style("fill-opacity", 0);
      t1.selectAll(".ctext").call(text2).style("fill-opacity", 0);
      t2.selectAll(".ptext").call(text).style("fill-opacity", 1);
      t2.selectAll(".ctext").call(text2).style("fill-opacity", 1);
      t1.selectAll("rect").call(rect);
      t2.selectAll("rect").call(rect);

      // Remove the old node when the transition is finished.
      t1.remove().each("end", function() {
        svg.style("shape-rendering", "crispEdges");
        transitioning = false;
      });
    }

    return g;
  }

  function text(text) {
    text.selectAll("tspan")
        .attr("x", function(d) { return x(d.x) + 6; })
    text.attr("x", function(d) { return x(d.x) + 6; })
        .attr("y", function(d) { return y(d.y) + 6; })
        .style("opacity", function(d) { return this.getComputedTextLength() < x(d.x + d.dx) - x(d.x) ? 1 : 0; });
  }

  function text2(text) {
    text.attr("x", function(d) { return x(d.x + d.dx) - this.getComputedTextLength() - 6; })
        .attr("y", function(d) { return y(d.y + d.dy) - 6; })
        .style("opacity", 1);
  }

  function rect(rect) {
    rect.attr("x", function(d) { return x(d.x); })
        .attr("y", function(d) { return y(d.y); })
        .attr("width", function(d) { return x(d.x + d.dx) - x(d.x); })
        .attr("height", function(d) { return y(d.y + d.dy) - y(d.y); });
  }

  function name(d) {
    return d.parent
        ? name(d.parent) + " / " + d.key + " (" + formatNumber(d.value) + ")"
        : d.key + " (" + formatNumber(d.value) + ")";
  }
}

if (window.location.hash === "") {
    d3.json("/dashboard/tags.json", function(err, res) {
        if (!err) {
            console.log(res);
            var data = d3.nest().key(function(d) { return d.tag; }).key(function(d) { return d.question; }).entries(res);
            main({title: "Recommended Tags"}, {key: "Tags", values: data});
            console.log(data[0])
        }
    });
}

</script>

<% content_for :js_scripts do %>

	
	<%= javascript_include_tag 'dashboard', 'data-turbolinks-track' => true %>

<% end %>
